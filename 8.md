# 참조
개강한 이후 알바 자리 알아보다가 프로젝트 하나를 해야만 했던 불운의 인간입니다.
다행히도 마감 기간 2주는 지나진 않은 것 같군요.

경황이 없어 많은 내용을 담기 어려우니 오늘은 일단 간단히 저번 시간에 다루지 못 했던 연산자 하나만 알려 드리려 합니다.
참조 연산자, `[]`입니다.

저번 시간 포인터로 배열을 표현할 수 있다 했었죠?
그 때 배열을 첫 번째 요소의 위치로 표현한다 배웠을 겁니다.

그러면 두 번쨰 배열의 값을 표현할 땐 어떻게 한다 했었죠?
첫 번째 요소의 위치에 1을 더하면 된다 했었죠?

그러면 배열 arr의 n 번쨰 요소의 위치를 확인할 경우에는 어떻게 하면 되겠어요?
```c
arr + n - 1
```

이렇게 쓰면 될 거에요.
그런데 이거 너무 길다고 생각한 사람들이 생각해 낸 아주 완벽한 대체제가 있었으니,

# []
대괄호에요.
이 친구가 하는 일은 간단합니다.
대괄호 안에 있는 거하고, 대괄호 왼쪽에 있는 거를 더한 다음에,
그 더한 값이 포인터라고 생각하고 그 값을 찾아 가는 거에요.

그러면 배열 arr의 n번쨰 요소의 값 확인할 때는 어떻게 하면 되겠어요?

```c
arr[n-1]
```

그렇죠. 그렇게 하면 됩니다.

이런 대괄호의 특징으로는 두 가지가 있어요.
그게 무엇인고 하니:
- 왼쪽에서 오른쪽으로 읽는다.
- 중첩 가능하다.
- 교환 법칙이 성립한다.

이 세 가지가 있습니다.
왼쪽에서 오른쪽으로 읽는 것은 너무나 당연한 소리니까 차치한다 치더라도
이런 특징은 이 연산자를 충분히 기괴하게 만드는 게 가능한데,

## 중첩 가능
사실 생각해 보면 간단합니다.
저것도 연산자잖아요.
충분히 중첩 가능하다는 걸 알 수 있습니다.
하지만 딱히 쓸 데는 없는 것 같죠?

지금 우리 이 단계에서는 포인터로 굳이 배열을 만들 필요는 없어 보이는데요.
그러면 이 중첩 가능하다는 것도 알아 봐야 쓸데가 없지 않을까요?

보통의 경우라면 그렇습니다.
그런데 다른 특징을 함께 적용하면 지옥도를 보실 수 있는데,

## 교환 법칙이 성립한다.
전 강의에서 배열의 위치를 찾아가는 것은 덧셈과 같다고 설명드렸습니다.
그리고 이번 강의에서 연산자 `[]`는 그저 더하기를 다르게 표현하는 것이라 설명드렸죠.

이 시점에서 여러분은 눈치 채실 수 있을 것입니다.
맞아요. `arr` 과 `i`는 자리를 바꿔도 딱히 상관이 없어 보입니다.

아까 위에서의 중첩 가능과 함꼐 다시 생각해 보죠.
중첩이 가능하다고 해도 처음에 얻은 값이 포인터가 아닌 이상 활용하기는 힘들어 보입니다.

하지만 그 다음으로 올 값이 포인터라면?
가령 이런 식으로 표현하는 것이 가능해 보입니다.

```c
arr[2][arr2]
```

# Quest
2주 동안 다른 거 하는지라 많은 내용을 담지 못한 점 죄송합니다.
다음에 돌아올 떄는 꽉꽉 채워 담으려 노오오오력해 보도록 하죠.

이번 퀘스트는 쉬어 가는 느낌으로 해 볼까요.

```c
long iae[] = {123,3,3,4,5432}, asd[] = {1,2,3,4};
```

이런 느낌의 배열이 있다고 생각하면,

```c
asd[1][iae][(char*)asd]
```

위 수식의 결과는 0입니다.
다음 시간까지 왜 그런지 알아오시고요.
