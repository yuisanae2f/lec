그래서 저번에 자료형 중에 포인터라는 게 있는데 다음에 알아보겠다 했었죠.
그래서 이번엔 `특별히` 포인터쨩만을 위해 이 자리를 빌어 글을 작성하고 있는데,
사실 포인터쨩이라 해도 별 거는 없습니다.

그냥 변수 위치 저장하는 거고요.

# 메모리
너가 변수면 그냥 있을 것이지 뭔 위치까지 있냐고요?
확실히 이게 틀린 말은 아닙니다.
`int a;`하고 변수를 만들어도 `어디에` 만들어라 같은 소리는 잘 안 하잖아요.
그러면 이 친구의 위치도 확인할 수 없어야 정상이겠네요. 그렇죠?

실은 그렇지 않습니다. 이게 어떻게 된 거냐면
`int a;`하고 변수를 만들어 놓으면 컴퓨터 이 `a`라는 이름에 그 변수의 위치도 함께 지정을 해 줍니다.
근데 `a`라는 이름 그 자체는 안에 들어 있는 값을 확인 하는데 써야 하는데,
그러면 그 주소를 확인하는 방법은 무엇인고, 하니

# 포인터
```c
int a = 3;
int* p = &a;
```
포인터라는 걸 이용하는 거에요.

보시면 p라는 변수에 `&a`를 집어넣는 걸 보실 수 있는데,
변수의 이름 앞에 이런 식으로 `&`를 적으면 해당 변수의 포인터를 얻을 수 있습니다.

그리고 자료형 이름 뒤에 `*`를 적으면 해당 자료형의 포인터 자료형을 얻을 수 있죠.
어라, 그러고 보니 이 `p`도 변수네요.
이 친구의 포인터 자료형도 만들 수 있지 않을까요?

```c
int a = 3;
int* p = &a;
int** pp = &p;
// ...
```
이런 식으로 찾아가는 것이 가능합니다.
포인터라는 자료형은 그 기초 자료형이 무엇이든 간에 다 똑같이 동작하기 때문에
`int*`이든 `char*`이든 다 같다고 볼 수 있습니다.
그 차이는 앞에 적혀 있는 자료형인데,

# 참조 연산자
포인터에서 값을 뽑아올 때 읽는 방식을 정하기 위한 방법이에요.
포인터 앞에 `*`을 적으면 포인터에서 값을 읽어 오는데,

그 읽어 오는 방식을 자료형으로 정한다고 했었죠?
그래서 포인터 앞에는 자료형이 들어가는 거에요.

```c
int a = 3;
int* p = &a;

printf("%d", *p);
```

이런 식으로 사용할 수 있고요.
# Quest
그래서 다음 시간까지 2강에서 보여 줬던 Goodbye 코드의 `printf` 부분 해석해 오시고요.