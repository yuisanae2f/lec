지금까지 여러분이 배운 것들을 나열해 보죠.  
변수, 기초 자료형, 함수, 포인터...  
훌륭하군요! 여러분이 제 글을 꾸준히 읽어 오셨다면 기초 프로그래밍 정도는 가볍게 할 수 있을 것 같습니다.  

오늘을 마지막으로 C언어 문법 자체는 줄여도 될 것 같습니다.  

문법 자체로서로는 막바지의 글에서 오늘은 함수나 변수의 범위에 대해 가볍게 알아 볼 건데,  

# 제어
지금까지 저는 코드가 main이든 이름이 어떻든 간 함수 안에서만 동작하도록 예시를 적은 바 있습니다.  
하지만 C언어는 제어 흐름을 함수 안에 짜야 하는 최상위 문을 지원하지 않는 언어죠.  

무슨 소리냐고요? if, else, for, switch, while 등의 제어문들은 함수 안에서 사용해야 한다는 뜻입니다.  
이렇듯 함수 안에서만 동작하는 것들이 또 뭐가 있었죠? 그렇습니다. 변수가 있는데,

# 지역
이런 함수 안을 어려운 말로 지역 범위라고 부릅니다.  
중괄호로 구분할 수 있는데, 이런 지역 범위에서 많이 활용되는 것 중 하나가 `지역 변수`라는 거에요.  

이 지역 변수는 대체로 여러분이 생각하는 것처럼 동작합니다.  
함수 안에서만 참조할 수 있고, 함수 바깥으로 나가면 메모리가 파기되어 참조할 수 없는 겁니다.  

그래서 함수가 새로 시작될 때마다 새로 만들어지는 변수들이죠.  
하지만 모든 변수가 이런 식으로 동작하지는 않습니다. 제어 코드나 함수 밖으로 못 나가지, 변수는 함수 밖에 선언해도 큰 문제는 없는데,

# 전역
이렇듯 바깥에 선언된 함수 및 변수를 기본적으로 '전역 범위에 속한다'고 부릅니다.  
그 말은 여러분이 한 번 함수 혹은 변수를 만들면 다른 파일에서도 같은 이름으로 사용할 수 있다는 뜻인데,

# extern
`extern` 키워드를 사용해서 "어딘가에 이런 게 있어!" 하고 컴파일러에게 알려 줄 수 있다는 거에요.  
예를 들어 다른 파일에서 이런 식으로 함수를 만들었다 하면,  
```c
int four = 4;
int three() { return 3; }
```

어딘가에서 정의되었기 때문에 main에서도 충분히 이 두 함수를 가져올 수 있다는 거죠.  
```c
#include <stdio.h>

int main() {
    extern int three(); // 다른 파일에 three() 라는 이름의 함수가 있다.
    extern int four;    // 다른 파일에 four라는 이름의 함수가 있다
    printf("%d %d", four, three());
}
```
이런 식으로 전역 범위에 선언을 해 두면 어디에서나 편리하게 함수를 끌어다 쓸 수 있습니다.  
하지만 이렇게 되면 불편한 점이 생기겠죠.  

C언어는 기본적으로 중복에 대해 굉장히 엄격한 언어기 때문에 같은 범위에 같은 이름의 내용이 다른 두 변수나 함수는 존재할 수 없습니다.  

```c
int a = 4; // 다른 파일에서 전역 변수 a를 지정한다.
```

```c
#include <stdio.h>
int a = 3; // 오류, 변수 int a를 재정의했다.
int main() {
    printf("%d", a);
}
```

그렇기 때문에 이름에 굉장히 민감해질 수밖에 없는데, 이런 불편함을 조상님도 느꼈는지 이를 해결하기 위한 키워드가 존재합니다. static이라는 건데,  

# static
static은 전역 범위에 선언된 함수나 변수의 범위를 정적 범위 내로 특정화시켜 주는 역할을 합니다.  
정적 범위 내가 뭐냐고요? 파일 밖에서는 이 함수를 읽을 수 없다는 뜻입니다.  
이런 static 함수는 여러분이 함수를 작성할 때 다른 파일로부터 숨기고 싶거나, 중복이 일어날 것 같은 함수가 쓸데 없이 많아지는 걸 방지할 수 있는데,

다른 스크립트에서 Three함수를 정의했다 하더라도,
```c
static int Three() {
    return 3;
}
```

위 static Three의 범위는 함수 내로 국한되어 있기 때문에 다른 이 메인 파일에서는 3이 아닌 4가 출력되는 것입니다.
```c
#include <stdio.h>
int Three() {
    return 4;
}

int main() {
    printf("%d", Three()); // 4
}
```

그러면 static의 장점이 뭐가 될까요?  
중복을 피하면서 때로는 같은 이름으로 다른 작업을 시킬 수 있다는 것이 강점이 될 수 있을 것입니다.  
그런데 이 static, 꽤나 신기하게 쓸 수 있습니다. 이 친구를 함수 안에 정의해 버릴 수도 있는데,

# 함수 안에서 static
```c
int m() {
    static int a = 0;
    return ++a;
}
```
이런 함수가 있다고 생각해 봅시다.  
이 m이라는 함수 안에는 `static int a`라는 변수가 초기화되어 있고, a에 1을 더한 뒤에 그 값을 반환하고 있군요.  

그러면 m이라는 함수의 반환값은 어떻게 될까요?  
a는 0부터 시작하고, 1을 더한 뒤 반환하니까 언제나 1이 되지 않겠습니까?  

실은 그렇지 않습니다. 이 static이라는 친구의 특징 때문인데:

static은 변수를 정적 범위에 할당시킵니다.  
즉슨 이 a라는 변수는 함수 m과는 별개로 동작한다는 의미인데,  
쉽게 말해서 a에 무슨 일이 있을 때마다 그 변화는 a에 전부 저장된다고 생각하시면 됩니다.  

따라서 m의 반환값은 `자기 자신이 불린 횟수`라고 할 수 있겠네요.

# Quest
C언어의 범위는 크게 4가지로 나뉠 수 있는데, 이번에 저는 세 가지의 범위를 가볍게 정리해 보았고요,  
재밌는 이야기 하나 해 보도록 하죠. C언어에서 무조건 main이라는 함수를 써야 하는 이유를 알고 계십니까?  

일명 프로그램의 진입점이라 해서, 수행하는 작업을 함수로 묶어서 저장하는 C언어에겐 제일 먼저 시작할 작업을 지정할 필요가 있기 때문인데,  
옛날에 그 작업을 메인 작업이다! 메인 루틴이다! 하여 main이라고 이름을 짓자 약속했기 때문이라 합니다.  

그러면 여기서 static int main()으로 진입점을 잡으면 어떻게 될까요?  
다음 시간까지 숙제로 그러면 어떻게 되는지와 왜 그렇게 되는지 레포트 써 오시고요.