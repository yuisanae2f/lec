반갑습니다. 24살(아님)입니다.  
최근에 아는 친구 중 하나가 서버에 들어왔습니다.  

본인 주장 제가 귓속말로 꼬셔서 코딩을 시작해 지금은 저보다 딥러닝을 딥하게 파고 있는 친구인데,  
서버에 들어와 제 정보글을 보고 피드백을 주셨습니다.

"조금 어려운 보스급 문제가 있는 게 좋을 것 같아."

ㅋㅋㅋㅋㅋㅋ 아 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
ㅋㅋㅋㅋㅋ아 보스 급 좋죠.  
오늘은 함수 포인터를 가지고 놀아 봅시다.

# 이게 존재하는 이유
그래요, 무슨 소리 하려는 건지는 알겠어요.  
"이런 젠장, 왜 이 세계에는 함수에도 포인터 같은 게 존재하는 거죠?"  

이유는 그리 어렵지 않습니다.

함수가 뭐에요?   
코드를 묶어다가 하나의 이름으로 저장하는 거 아니겠어요?  

그러면 결국에는 함수도 코드를 저장하는 하나의 변수로 봐도 되지 않을까요?  
그렇게 생각해도 될 것 같습니다.

그래서 이거 알아서 써먹을 데가 있기는 하냐고요?  
있습니다. 이게 코드를 좀 유연하게 만들고 싶을 때 쓸 수 있는데,

# 이거 쓰는 법
할 일을 기억해 둬야 할 때 쓰거나, 해야 할 일을 잘 모르겠을 때 쓰는 거에요.  
예를 들어, 더하기를 만든다고 가정을 해 보도록 합시다.  

## add를 만들어 보자
두 개의 인수를 입력받아서, 더한 값을 출력을 하고 싶은 거에요.  
그러면 어떻게 코드를 짜면 되겠어요?  

```c
int add(int a, int b) {
    return a + b;
}
```

정수 두 개를 입력받아서, 더하기를 수행한 다음 반환하면  
두 정수의 덧셈을 수행할 수 있겠네요. 그렇죠?

하지만 여기에는 문제가 있습니다.  
저 함수는 `int`형태로만 덧셈을 수행할 수 있다는 거죠.

C에서는 이런 상황을 모면할 방법이 존재하지 않습니다.  
하지만 적어도 함수를 사용하는 사람이 덧셈의 수행을 결정하게 만들 수 있죠.  

여기에서 바로 함수 포인터를 사용할 수 있는 겁니다.

## 선언
함수 포인터로 변수를 만들고 싶어요? 이렇게 하시면 됩니다.

```c
returntype(*varName)(argType1, argType2);
```

returntype은 반환할 형식이에요.  
varName에 원하는 변수 이름을 넣으면 되고요.  
옆에 있는 괄호 안에 입력으로 받을 인수들의 자료형을 정의하시면 돼요.  

그러면 반환 형태가 없고 int 형태의 인수가 두 개 있는 함수는 어떻게 정의하면 될까요?

```c
void(*funptr)(int, int);
```

이렇게 하면 될 것 같습니다.

## typedef
이름이 너무 복잡해서 매번 치기가 너무 귀찮아요?  
함수 포인터는 여느 자료형과 같이 `typedef` 키워드를 사용하여 새로운 이름을 붙여 주는 것이 가능합니다.  

```c
typedef void(*noreturnInt2)(int, int);
noreturnInt2 a;
```

## add를 다시 짜 보자
그러면 이런 식으로 한 번만 정의해 주면 복잡한 형태 없이 변수 선언하듯 선언할 수 있는 겁니다.  
그럼 이제 add함수의 제어를 쓰는 사람이 직접 정하게 해 줄 수 있겠네요.

어떻게 짜면 되겠어요?  
입력으로 함수 포인터를 받으면 미리 정의된 함수를 넣어서 동작을 조작하도록 할 수 있지 않을까요?  
그러면 될 것 같습니다.

```c
int add(int a, int b, int(*fun)(void*, void*)) {
    return fun(a, b);
}
```

보시다시피, 함수 포인터는 함수처럼 괄호를 사용하여 불러올 수 있습니다.  

지금은 코드가 너무 단순해서 함수 포인터를 사용하는 데에 큰 메리트가 느껴지지 않을 수 있습니다.  
코드의 복잡도에 비해 하는 행동이 너무 단순해서 그래요.  
한 번에 여러 개의 행동을 하길 바랄 경우에는 상황이 달라질 수 있습니다.  

함수 포인터를 배열로 입력받거나, 여러 개의 값에 일괄된 동작을 수행하는 걸 시도하시면 돼요.  
비교적 쉬운 함수 포인터 배열 입력 받기를 먼저 해 보자면:

## 함수 포인터를 배열로 받아 보자
```c
#include <stdio.h>

void code0(int a, int b) {
	printf("a + b = %d\n", a + b);
}

void code1(int a, int b) {
	printf("a - b = %d\n", a - b);
}

void(*funptrarr[])(int, int) = { code0, code1 };

void delegated(int a, int b, void(**funarr)(int, int), int len) {
	for (int i = 0; i < len; i++)
		funarr[i](a, b);
}

int main() {
	delegated(3, 12, funptrarr, 2);
	return 0;
}
```
이 코드는 함수 포인터 여러 개를 묶어 배열로 만든 이후에, 그걸 하나의 함수에서 실행하고 있는 예제에요.  
그러면 이 코드의 출력은 어떻게 될까요?  
코드를 찬찬히 뜯어 보면 알 수 있습니다.

`code0`은 정수 두 개를 받아서 그 둘을 더한 값을 출력합니다.  
`code1` 또한 마찬가지로 두 정수를 받지만 이번에는 그 둘을 뺀 값을 출력하죠.  

두 함수의 매개 변수와 반환 자료형이 같다는 뜻입니다.   
여기에서 `funptrarr`이 `code0`과 `code1`의 위치를 저장하죠. 함수 포인터의 배열이라는 뜻이에요.

`delegated`라는 함수에서 그 배열을 사용할 겁니다.  
이 함수는 두 정수를 받고, `funarr`이라는 함수 포인터의 위치를 받은 뒤, 그 포인터가 배열이라 가정하고 그 배열의 길이 `len`을 받고 있어요.  
그걸 어떻게 아냐고요? 평범한 함수 포인터와는 달리 변수의 이름 앞에 별이 두 개 달려 있죠? 포인터의 포인터라는 뜻이에요.

`delegated`는 이후에 `funarr`의 모든 요소에 접근하며, 저장된 함수에 입력받은 정수 `a`, `b`를 넣어 실행합니다.  
그러면 이 프로그램의 출력은 어떻게 되겠어요?

함수 `main`를 보면 `delegated`를 호출하고 있네요.   
`a`과 `b`에는 3과 12, `funarr`에는 `funptrarr`, 을 넣고 있습니다.

`funarr`에는 {`code0`, `code1`}이 들어가 있으니 출력은 이렇게 되겠네요.

```
a + b = 3
a - b = -9
```

그러면 `funarr`에 함수를 추가하거나, 함수의 동작을 바꾸는 것 또한 가능하지 않을까요?  
그럴 것 같습니다.

# Quest
오늘 알아 본 것은 함수 포인터입니다.  
생긴 게 조금 복잡한 것 뿐이지, 별 건 없어요.

그냥 할 일 저장하는 방법 중 하나라고 생각하시면 편합니다.  
다만 그냥 생긴 게 좀 험악한 것 뿐이죠.  

이 생긴 것에 대해 이야기를 좀 하자면, 이론상 함수 포인터를 반환하면서 동시에 함수 포인터를 입력받는 함수 같은 거 만드는 건 일도 아니거든요.  
결국에는 포인터 또한 커다란 정수에 불과하니까, 이론상 불가능한 건 아니다 이거죠.  
그런 의미에서 오늘의 퀘스트는 간단한 걸로 내도록 하겠습니다.  

```c
double(*(*function(const char* str))(int, void(*)(int, float)))(int[], unsigned int);
```

노란색 이름을 보시면 아시다시피 이것은 무언가 입력을 받고 무언가 반환하는 함수입니다.  
이 함수를 분해해서 어떤 입력을 받고 어떤 반환을 받는지 적어 주시면 되겠습니다.  
분해는 typedef로 하시면 돼요.

행운을 빕니다.