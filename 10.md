# 함수
우리는 몇 줄만 가볍게 쓰고 있다 보니 불편함을 느낄 일이 잘 없겠지만, 사실 모든 코드를 main 안에 다 때려박는 건 너무나 불편한 일입니다.

언제까지 기존 알고리즘 짤 때마다 메모장에서 복붙에서 써야 되겠어요?
그거 변수 이름 바꾸는 거도 귀찮고, 주석 다는 거도 귀찮고, 계속 그렇게 하다가 귀찮아져서 안 바꾸다 보면 여러분의 코드가 늙고 병들게 될 텐데,

이게 다 코드 재활용성이라는 게 떨어져서 그렇습니다.
도대체 그게 뭐냐고요? 말 그대로 당신이 짜 놓은 코드가 재활용이 얼마나 잘 되는지 본다는 건데,

# 코드 재활용성
쉽게 말해 똑같은 코드 쓰는 걸 얼마나 잘 피하냐는 소리에요.
만약에 1부터 10까지를 출력하는 알고리즘을 짜고 싶다! 생각해 봅시다. 어떻게 하면 1부터 10까지 출력해 낼 수 있을까요?

printf("1\n"); 부터 printf("10\n"); 까지 쓰면 되는 거 아니에요?
실제로 코드를 써 보면 이렇게 생겼겠네요.

```c
#include <stdio.h>
int main() {
    printf("1\n");
    printf("2\n");
    printf("3\n");
    printf("4\n");
    printf("5\n");
    printf("6\n");
    printf("7\n");
    printf("8\n");
    printf("9\n");
    printf("10\n");

    return 0;
}
```

그렇죠? 확실히 그러면 일단 출력은 1부터 10까지 잘 되지 않겠어요?
그렇습니다. 하지만 거기에는 아주 사소한 문제가 있을 수 있는데,

- 그거 100까지 출력하라고 하면 어떻게 할 거에요?
- 몇까지 적을 건지 입력 받을 거라고 하면요?
- 4부터 시작하고 싶다!라고 하면 어떻게 하실 건데요?

그걸 하나하나 다 적고 있는 건 아주 효율이 떨어져 보입니다.
당연히 멍청하게 그걸 다 적고 있는 개발자는 없습니다.
그냥 반복문 쓰고 말 일 아니에요?

```c
#include <stdio.h>

int main() {
    for(int i = 1; i <= 10; i++) {
        printf("%d\n", i);
    }

    return 0;
}
```

어때요? 훨 깔끔하지 않나요?
이러면 저 위에 있는 인수를 조정하는 것만으로 여러 가지를 정할 수 있겠죠?
그렇습니다. 저 위에서 제가 제시한 조건 이외에도 여러 가지를 유연하게 대처할 수 있겠네요. 저 가련한 세 줄 짜리 반복문 따위가 말이에요.

하지만 저 for문은 같은 코드를 그저 지정된 조건에 맞춰 반복시키기만 하는 세뇨 달 세뇨 코다 코다 피네에 불과하다는 것을 알 수 있습니다.
뭔지 모르겠다고요? 글쓰기 강의하는 사람한테 문의하시면 되고요.

그래서 그거면 됐지 뭘 더 바라시냐고요?
그런 추상화 따위 필요 없지 Assembly-male적인 마인드는 존경하는 바입니다만 저희 같은 허~접 초식남 단순 개발자들은 구현에 사용되는 코드에 반복이 많아지면 해당 로직을 바꾸는 것도, 단순 코드에 사용되는 바이트 수가 많아지는 것도 고민이 될 수 있습니다.

그럼 그걸 어떻게 
그럴 때 구현하는 방식을 다른 곳에 적어 두고, 원하는 방식으로 불러 오면 되는 거 아니겠어요?

여러분이 메모장이나 gist 같은 곳에 코드 붙여 넣는 거를 자동화할 수 있다는 뜻 아니겠습니까?

그런 게 실제로 있습니다.
함수라는 건데,

# 함수
함수가 무엇이냐? 라는 설명은 초등학교부터 대학교까지 설명이 다양해 질 수도 있고, 심지어 여러분이 뭘 배우냐에 따라 그 정의가 달라지는 경우도 있습니다.

그러니 프로그래밍에서 함수가 뭔지 정확하게 여러분이 알지 못 해도 괜찮습니다. 초등생도 알 법한 설명으로 함수를 이해할 수 있는데,

함수는요, 데이터를 넣으면 데이터를 주는 상자 같은 거에요.
물론 그 과정에서 제어문이나 부가 기능이 존재하는 시점에서 이걸 함수라고 부를 수 있는가에 대한 거는 논란이 될 수 있겠지만, 그래도 코드 짜는 데에는 별 문제가 없으니 넘어갈 수 있는 거 아니겠어요?

그래서 그 함수라는 거 어떻게 짜냐고요?
아주 간단합니다. 그도 그럴 게 저는 매번 여러분이 코드 짤 때마다 함수를 하나 이상 만들라고 하고 있어요.

바로 main함수입니다. 이거처럼 하시면 되는데,

## 선언과 구현
그래서 main 어떻게 선언하냐고요?
벌써 까먹은 학생이 있는 거 같으니 복습을 좀 하도록 하죠.

```c
int main() {
    // whatever the shit you've got to write
    return 0;
}
```

이 간단한 코드에서 함수의 구성 요소를 엿볼 수 있습니다.
그걸 간단히 추려서 설명해 보면 이렇게 되는데,

- int: 반환할 함수의 자료형
- main: 함수 이름
- (): 함수에서 받을 입력
- {}: 함수 안에서 할 거
- return: 이 함수 멈추겠다. 이 함수의 값은 이 다음이 될 것이다.
- // whatever the shit you've got to write: 그냥 주석

적어 놓고 보니까 `()`인지 뭔지 하는 이상한 게 끼어 있지 않나요?
main 함수는 입력 같은 거 안 받고 있지 않습니까. 안 그래요?
그렇습니다. 입력을 안 받고 있으니 괄호 안을 비워 둔 건데,
그럼 입력을 받고 싶으면 어떻게 하면 되냐고요?
그 안에다가 변수를 선언해 버리시면 됩니다.

```c
// 선언만 하고 본문 안 적을 때는 이러시면 됩니다.
// 당연하게도 나중에 이거 쓰고 싶으면 본문 작성 따로 하셔야겠죠.
int f(int x);
int fforxy(int x, int y);
```

차이가 조금 있죠? 어떤 차이가 있어요?
`main` 안에서 변수 선언 할 때는 x와 y를 선언할 때 구분을 위해 세미콜론(`;`)을 썼는데, 여기에서는 쉼표(`,`)를 쓰고 있네요.

생각해 보면 이유는 간단합니다.
`printf` 함수 같은 거 보면 여러 개 입력 넣고 싶을 때 쉼표로 구분하잖아요? 선언 때도 똑같이 하는 겁니다.

이렇게 선언과 구현을 끝내면 `printf`처럼 자신만의 로직을 정의한 함수를 만들 수 있게 되는 거에요.

그런데 이거 뭔가 변수랑 닮지 않았어요?
선언과 구현을 따로 할 수 있는 것도, 똑같은 거 여러 번 쓰기 귀찮아서 만드는 것도 변수랑 비슷하잖아요.

그렇습니다. 함수도 엄연히 메모리를 먹는 변수인지라 당연하게도 포인터가 존재하는데,

## 함수 포인터
함수의 포인터를 구하는 방법은 간단합니다.
배열이랑 똑같이 함수의 이름 자체가 함수의 포인터를 뜻하고요, 아마 여러분이 main의 포인터를 들고 오면 0이 될 겁니다.

진입점이라서 그런 거고요.

그 포인터의 형식이 중요하죠?
예를 들어서
```c
int f(int x);
```

처럼 생긴 함수의 포인터는 다음과 같습니다.

```c
int(*f)(int);
```

그렇다고 매번 함수 포인터로 변수 만들 때마다 이걸 전부 적을 수는 없는 노릇이니, `typedef`를 이용해 반복을 줄일 수 있겠고요,

```c
int f(int x);
typedef int(*f_int_int)(int);
f_int_int d = f;
```

위와 같이 사용할 수 있는 겁니다.

그렇습니다. 요약하자면 함수는 코드를 따로 다른 곳에 저장해 놓고 그 위치에 찾아가서 원하는 로직을 실행하는 과정을 쉽게 만든 것이라 할 수 있습니다.

그러면 어떤 로직을 반복적으로 사용해야 할 경우에, 함수를 사용할 경우 코드의 용량을 줄일 수 있겠네요. 그렇죠?

확실히 그렇습니다. 하지만 어디까지나 위치를 찾아서 실행하는 과정이기 때문에 함수 실행할 때 시간이 조금 걸릴 수 있습니다.

이걸 오버헤드라고 하는데, 함수 안에 있는 내용이 좀 복잡한 경우 아니면 상당히 거슬리는 경우도 있습니다.

그래서 그걸 해결하기 위한 방법이 있는데, 인라인이라는 거고요.

## 인라인

함수를 선언 및 구현할 때 앞에 inline을 붙이면 매크로를 창조할 수 있습니다.

그렇게 하면 함수처럼 동작하는 건 똑같지만, 어느 위치에 저장하는 게 아니라 실행할 수 있는 파일을 만드는 도중에 자신이 가지던 해당 코드를 전부 함수를 실행하는 위치에 꼴아박는 겁니다.

다시 말해 함수 짝퉁이라고 할 수 있죠.
그러면 어떻게 되겠어요? 말 그대로 코드를 붙여넣는 툴일 뿐이기 때문에 함수 포인터 같은 게 만들어질 리가 없겠죠?

이렇게 하면 장점이 있습니다.

어느 위치에 저장하고 찾아가는 게 아니라서 찾아가는 시간, 오버헤드가 거의 발생하지 않는다는 거죠.

그런데 문제는 이런 inline이 여러 번 사용되면 실행 가능한 코드의 전체 길이는 함수를 사용하지 않으니만 못하다는 문제가 된다는 거죠.

하지만 요새 컴파일러들 사람보다 더 똑똑해져서 자기 알아서 인라이닝하든 안 하든 결정하니까 우리 같은 허접들이 생각할 필요는 없고요.

그냥 "이런 게 있구나" 하면서 넘어가셔도 무방합니다.

# Quest
자 그럼 오늘 함수에 대해 알아보았고요.
오늘의 퀘스트를 소개해 드리도록 하죠.

다음 시간까지 INPUT_TYPE, INPUT_VALUE, makePass4의 함수 내용을 변경하여 pass의 값이 4가 되도록 바꿔 오시고요.

```c
#include <stdio.h>

#define INPUT_TYPE
#define INPUT_VALUE

void makePass4(
    INPUT_TYPE a
) {
    // 이 함수의 로직을 변경하십시오.
    return;
}

int main() {
    int pass;

    makePass4(
        // 이 밑, 값이 들어갑니다.
        INPUT_VALUE
    );

    printf("%d", pass);

    return 0;
}

```